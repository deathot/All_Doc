### 2-1. 进程基本概念
1. **进程执行分析及前趋图**
> 1. 前趋图概念及举例说明
>> - P1是P2的直接前趋, P2是P1的直接后继
> 2. 前趋图中必须不存在循环
2. **程序顺序执行**
> 1. 顺序执行
> 2. 顺序执行时的特征
>> - 顺序性
>> - 封闭性
>> - 可再现性
3. **程序并发执行**
> 1. 并发执行
> 2. 并发执行特征
>> - 间断性
>> - 失去封闭性
>> - 不可再现性
4. **进程的定义及特征**
> 1. 进程的引入
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 5.29.21 PM.png" width=50%></img></center>
> 2. 进程的定义
>> - 进程是可并发执行的程序在一个数据集合上的运行过程, 亦即进程实体的运行过程
>>> 1. 进程实体由程序段、 数据段及进程控制块三部分构成
>> - 进程是系统进行资源分配和调度的一个独立单位
> 3. 进程的特征-与程序的区别与联系
>> - 结构特征 
>> - 动态性
>> - 并发性
>> - 独立性
>> - 异步性
5. **进程状态及状态转换图**
> 1. 进程的基本状态及状态转换
>> - <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 6.55.30 PM.png" width=50%></img></center>
> 2. 引入挂起状态的可能原因
>> - 终端用户、父进程、OS、负载调节的请求
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.01.34 PM.png" width=50%></img></center>
6. **UNIX进程状态转换图**
> 1. 状态图
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.09.40 PM.png" width=50%></img></center>
7. **Linux进程状态转换图**
> 1. 状态图
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.17.50 PM.png" width=50%></img></center>
---
### 2-2. 进程控制
1. **进程控制块**
> 1. 进程控制块
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.51.22 PM.png" width=50%></img></center>
> 2. 块中的信息
>> - 进程标识符
>> - 处理器状态信息
>> - 进程调度信息
>> - 进程控制信息
> 3. 进程图(进程🌲)
> 4. 进程控制块的组织方式1-链接方式
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.58.31 PM.png" width=50%></img></center>
> 5. 进程控制块的组织方式1-索引方式
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-21 at 7.59.50 PM.png" width=50%></img></center>
2. **Linux task_struct结构体**
> 1. Pass
3. **进程的创建与终止**
> 1. 引起事件
>> - 用户登入/作业调度/提供服务/应用请求
>> - 正常结束/异常结束/外界干预
> 2. 进程创建/终止过程
>> - Create()原语
>>> 1. 分配标识符,并申请空白进程控制块
>>> 2. 为新进程的程序和数据及用户栈分配必要的内存空间
>>> 3. 初始化进程控制块
>>> 4. 将新进程插入到就绪进程队列
>> - Terminate()原语
>>> 1. 检索被终止进程PCB, 读取进程状态
>>> 2. 若正处于执行状态, 应立即终止执行并设置调度标志为真, 以指示调度新进程
>>> 3. 终止子孙进程
>>> 4. 资源归还
>>> 5. 移出被终止进程PCB, 等待其他程序查询利用
4. **进程的阻塞与唤醒**
> 1. 引起事件
>> - 请求系统服务/启动某种操作/新数据尚未到达/无新工作可做
>> - 系统服务满足/操作完成/数据到达/新任务出现
> 2. 进程阻塞/唤醒过程
>> - Block()原语
>>> 1. 立即停止执行, 把进程控制块中的现行状态由"执行"改为阻塞, 并将它插入到对应的阻塞队列中
>>> 2. 转调度程序进行重新调度, 将处理机分配给另一就绪进程, 并进行切换
>> - Wakeup()原语
>>> 1. 将阻塞进程移出, 改PCB为就绪状态, 再将进程插入就绪队列
5. **进程的挂起与激活**
> 1. 进程挂起/激活过程
>> - Suspend()原语
>>> 1. 检查被挂进程现行状态并修改和插队
>>> 2. 复制PCB到指定域
>>> 3. 若被挂进程正在执行则转向调度程序重新调度
>> - Activate()原语
>>> 1. 检查进程现行状态并修改和插队
>>> 2. 若有新进程进入就绪队列且采用了抢占式调度策略, 检查和决定是否重新调度
6. **UNIX进程描述与控制概要**
> 1. 进程控制数据结构
> 2. 进程映像
>> - 进程是进程映像的执行过程, 进程映像则是正在运行进程的实体
>>> 1. 用户级上下文/寄存器上下文/系统级上下文
> 3. 进程控制
>> - fork系统调用/exit系统调用/exec系统调用/wait系统调用
> 4. 进程调度与切换
>> - 调用算法/进程优先级分类/优先数计算/进程切换
---
### 2-3. 进程同步机制
1. **进程并发制约关系及临界区**
> 1. 并发进程间制约关系
>> - 资源共享关系-间接制约
>> - 相互合作关系-直接制约
> 2. 临界资源
>> - 一段时间内只允许一个进程访问的资源
> 3. 临界区
>> - 保证互斥的访问资源
> 4. 临界资源的循环进程描述
2. **进程同步机制准则**
> 1. 准则
>> - 空闲让进/忙则等待/有限等待/让权等待
3. **进程互斥访问临界资源的软件解决方案-算法1**
> 1. 进程互斥问题
> 2. 互斥算法1-设置访问编号
>> <center><img src="/操作系统/All_pic/Screenshot 2024-09-23 at 3.20.25 PM.png" width=50%></img></center>
4. **算法2**
> 1. 设置访问标志
5. **算法3**
> 1. 设置欲访问标志
6. **算法4-Peterson算法**
> 1. 编号+标志(Peterson算法)
7. **硬件方法**
> 1. Test-and-Set指令
> 2. Swap指令
8. **整形信号量机制**
> 1. 整型信号量
>> - wait(s): while s ≤0 do no_op;
>> - s := s-1;
>> signal(s): s := s+1;
9. **记录型信号量机制**
> 1. 信号量类型说明
>> ```
>> type semaphore = record
>>     value: integer;
>>     L: list of process;
>> end
>> ```
> 2. wait(s)操作描述
>> ```
>> procedure wait(s)
>> Var s: semaphore;
>> begin
>>     s.value := s.value - 1;
>>     if s.value < 0 then block(s.L);
>> end
>> ```
> 3. signal(s)操作描述
>> ```
>> procedure signal(s)
>> Var s: semaphore
>> begin
>>     s.value := s.value + 1;
>>     if s.value ≤ 0 then wakeup(s.L);
>> end
>> ```
10. **AND型信号量集机制**
> 1. 引入
>> - 多个进程要引入两个以上的资源时, 记录型信号量机制可能导致死锁
>> - 对策: 若干个临界资源的分配采取原子操作方式
> 2. Swait(s1, s2, sn)操作
>> <center><img src="/操作系统/All_pic/屏幕截图 2024-09-25 234001.png" width = 50%></img></center>
> 3. Ssignal(s1, s2, sn)操作
>> <center><img src="/操作系统/All_pic/屏幕截图 2024-09-25 234256.png" width = 50%></img></center>
1.  **一般信号量集机制**
> 1. 引入
>> - 记录型信号量/AND型信号量机制, waits/signal一次只能操作1, 效率低下
>> - 且当资源数量低于某一下限.所以需要测试
>> - 所以需要一般化的"信号量集"机制
> 2. Swaits操作 
>> <center><img src="/操作系统/All_pic/屏幕截图 2024-09-25 235010.png" width = 50%></img></center>
> 3. Signal操作
>> <center><img src="/操作系统/All_pic/屏幕截图 2024-09-25 235226.png" width = 50%></img></center>
> 4. 特殊情况
>> - Swait(s, d, d)
>>> 1. 信号量集中只有一个信号量, 但每次允许分配d个资源; 当现有资源少于d个时, 便不予分配
>> - Swait(s, 1, 1)
>>> 1. 此时的信号量集已退化为一般的记录型信号量
>> - Swait(s, 1, 0)
>>> 1. 特殊且有用的信号量, 相当于可控开关
>>> 2. 当s >= 1时, 允许多个进程进入特定区; 当s变为0, 将阻止任何进程进入特定区
