### 3-1. 调度类型与模型
#### 1. 处理器调度及多级调度
1. 多道程序环境与处理器调度
    - 作业类型与处理器获得过程
        1. 批量型、终端型作业
    - 基于操作系统类型的调度分类
        1. 批处理/分时/实时调度及多处理机调度
    - 调度是多道程序系统的关键所在
        1. 系统运行性能
        2. 作业的提交要经历高级、中级、低级及I/O等多级调度
2. 多级调度示意图
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-04 at 21.32.38.png" width=50%></img></center>
3. 高级调度(作业/长程/宏观调度)
    - 概念
        1. 外存上处于后背队列的作业调入内存, 并创建进程和分配资源, 然后再将新进程插入到就绪队列来准备执行
    - 操作系统配置作业调度机制分析
        1. 批处理系统
    - 作业调度机制要领
        1. 作业量确定
        2. 作业选择
4. 低级调度(进程/短程调度)
    - 概念
        1. 决定就绪队列中哪个进程获得处理机, 再由分派程序(Dispatcher)执行把处理机分配来具体操作
    - 操作系统配置进程调度机制分析
        1. 基本调度, 所有类型操作系统都要分配
    - 调度方式分类
        1. 非抢占式(批处理系统)
        2. 抢占式(分时、实时、批处理)
5. 中级调度(中程调度)
    - 概念
        1. 为提高内存利用率和系统吞肚量, 来使暂时不能运行的进程放弃占用内存资源, 调到外存等待; 内存有空闲时, 再将外存中具备运行条件的就绪进程重新调入内存, 修改状态并挂到进程队列中等待进程调度
    - 实质
        1. 存储器管理中的对换功能
#### 2. 处理器调度队列模型
1. 具有三级调度的调度队列模型
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-04 at 21.47.02.png" width=50%></img></center>
---
### 3-2. 调度算法及评价标准
#### 1. 处理器调度评价准则
1. 选择调度方式和算法的若干准则
    - 面向用户的准则(与OS类型有关)
        1. 周转时间
        2. 响应时间
        3. 截止时间
        4. 优先权准则
    - 面向系统的准则
        1. 系统吞吐量
        2. 处理机利用率
        3. 各类资源的平衡利用
#### 2. 先来先服务调度算法
1. 举例分析
     <center><img src="/操作系统/All_pic/Screenshot 2024-10-04 at 22.00.04.png" width=50%></img></center>
2. 先来先服务调度算法FCFS
    - 基本思想
        1. 作业调度
        2. 进程调度
    - 算法特点
        1. 有利于长作业(进程)
        2. 有利于CPU繁忙型作业(进程)不利于I/O繁忙型作业(进程)
#### 3. 最短运行时间优先调度算法(短作业/进程优先调度算法)
1. 短作业优先调度算法SJF/SJN
    - 基本思想
        1. 选取服务时间最短的**若干道**作业装入内存, 采用适当进程调度算法执行
        2. 单道批处理/多道批处理系统
    - 算法特点
        1. 降低作业平均等待时间提高吞吐量
        2. 不利于长作业
        3. 未考虑作业紧迫程度
        4. 作业服务时间估计不准确性
2. 短作业(进程)优先调度算法举例
     <center><img src="/操作系统/All_pic/Screenshot 2024-10-04 at 22.19.38.png" width=50%></img></center>
3. 进程运行过程特点及调度考量
    - 进程运行过程分析
        1. 计算与I/O交替发生
        2. 交互式作业I/O时运行时间短
        3. 批处理作业I/O时可能运行很长时间
    - 进程调度考量
        1. 交互式作业较高优先级, 基于进程下一轮的处理器集中使用时间(I/O操作之间的时间量, CPU burst)的长短来确定相应优先级
        2. 根据进程以往执行情况来推测时间量
4. 最短运行时间优先调度算法SRTF
    - 基本思想
        1. 进程调度: 选取下一轮最短的进程, 优先执行
    - CPU burst公式
        1. $$E_i = (\Theta * T_{i-1}) + ((1 - \Theta) * E_{i-1})$$
        2. $$\Theta \in[0, 1], 可初始化为0.5$$
    - 算法特点
        1. 优先执行交互式作业, 改善用户体验
        2. 未考虑进程紧迫度
#### 4. 高优先权优先调度算法
1. 算法FPF
    - 基本思想
        1. 照顾紧迫型作业(进程)
    - 算法分类
        1. 非抢占式
        2. 抢占式
    - 优先权类型(确定依据: 进程类型、资源需求、用户要求)
        1. 静态
        2. 动态
#### 5. 高响应比优先调度算法
1. 算法
    - 基本思想
        1. 短作业+动态优先权的调度算法
    - 优先权(响应比)
        1. (等待时间 + 要求服务时间)/要求服务时间
    - 算法特点
        1. 短作业与先后次序兼顾, 不会使长作业得不到服务
        2. 响应比计算系统开销
#### 6. 时间片轮转调度算法
1. 算法
    - 基本思想
        1. 先来先服务原则排队
        2. 时间片及时钟中断
    - 时间片大小的确定
        1. 系统对响应时间的要求
        2. 就绪队列中的进程数目
        3. 系统的处理能力
2. 算法分析举例
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-05 at 17.56.18.png" width=50%></img></center>
#### 7. 多级队列调度方式及多级反馈队列调度算法
1. 多级队列调度方式
    - 引入的必要性
        1. 多OS类型配置
        2. 批量/交互性作业性质不同
    - 基本思想
        1. 作业性质分类排列, 不同队列不同算法
    - 队列间关系处理
        1. 优先权方式
        2. 前/后太比例方式
2. 多级反馈队列调度
    - 引入
        1. 各类算法均有局限性
    - 基本思想
        1. 设置多个队列并赋予不同优先权
        2. 不同队列的执行时间片大小不同
        3. 先来先服务/时间片轮转调度算法结合
        4. 调度准则和抢占式优先权调度
    - 算法性能
        1. 满足如终端型、短批、长批等作业/用户要求
#### 8. 实时调度算法概要
1. 算法分类
    - 根据实时任务不同
        1. 硬实时/软实时调度算法
    - 调度方式不同
        1. 抢占式/非抢占式
    - 调度策略实施方式
        1. 静态/动态调度算法
    - 基本调度策略分类
        1. 时间片轮转/优先级调度算法
    - 对处理机环境
        1. 集中式/分布式调度
2. 常用实时调度算法
    - 最早截止时间优先调度算法(EDF-Earliest Deadline First)
    - 最低松弛度算法(LLF-Least Laxity First)
#### 9. EDF算法
1. 算法举例1(开始截止时间)
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-05 at 18.09.01.png "width=50%></img></center>
2. 算法举例2(两类周期性)
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-05 at 18.09.45.png" width=50%></img></center>
#### 10. LLF算法
1. 算法举例(两列周期性)
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-05 at 18.11.50.png" width=50%></img></center>
---
### 3-3. 死锁及处理方法
#### 1. 死锁概念及成因分析
1. 基本概念
    - 死锁(deadlock): 多道程序系统中, 并发执行的多个进程争夺资源而造成的僵局
    - 资源分类: 可/不可剥夺资源, 可重用与消耗性资源
2. 资源分配图
    - Pass
3. 死锁产生原因之一: 竞争资源
    - I/O设备共享时, 竞争不可剥夺资源
    - 进程通信时, 竞争临时性资源
4. 原因之二: 进程次序不当
    - Request/Release/Process之间的问题
5. 死锁必要条件
    - 互斥条件
    - 请求和保持
    - 不剥夺
    - 环路
#### 2. 死锁处理方法概要
1. 基本方法
    - 预防死锁: 设置限制前提破防产生死锁的必要条件
    - 避免死锁: 防止进入不安全状态
    - 检测: 检测机构, 精确相关进程和资源
    - 解除: 撤销/挂起, 回收和分配
#### 3. 死锁预防策略
1. 策略一
    - 摒弃"请求和保持"条件
        1. 进程开始前, 一次性申请整个过程所需资源
        2. 简单, 安全
        3. 资源浪费, 进程延迟
2. 策略二
    - 摒弃"不剥夺"条件
        1. 进程需要资源时提出请求, 得不到满足就释放已占有资源
        2. 实现复杂, 代价大(反复申请与释放)
3. 策略三
    - 摒弃"环路等待"条件
        1. 所有资源按类型线性排队, 进程的请求严格按序号提出
        2. 资源次序不灵活性(逻辑设计)
#### 4. 死锁的检测与解除
1. 死锁定理: 死锁充要条件是**当且仅当该状态下资源分配图是不可完全化简的**
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-08 at 17.40.45.png" width=50%></img></center>
2. 死锁检测算法
    - for循环所有进程来检测是否死锁
3. 死锁的检测与解除
    - 基本方法
        1. 剥夺其他进程资源给死锁进程
        2. 撤销死锁进程
    - 策略及评价
        1. 解除死锁所撤销的进程数
        2. 撤销所付出的最小代价
4. 实例评析
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-08 at 17.46.38.png" width=50%></img></center>
#### 5. 死锁避免策略及相关概念
1. 死锁避免
    - 基本思想: 允许进程动态地申请资源, 但先进行安全性检查, 否则拒绝分配
2. 死锁避免基本概念
    - 安全状态
        1. 系统可按某个安全分配序列为每个进程分配资源
    - 不安全状态
        1. 系统无法找到一个安全序列
    - 死锁与状态安全性之间的关系
        1. 并非所有不安全状态都是死锁状态
        2. 进入不安全状态有可能陷入死锁
#### 6. 银行家算法设计要旨
1. 数据结构
    - 可利用/请求资源: Available/Request
    - 最大需求矩阵/分配/需求: Max/Allocation/Need
    - 工作向量/Finsh布尔向量: Work/Finish
2. 算法主体
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-08 at 17.56.08.png" width=50%></img></center>
3. 安全性子算法
    <center><img src="/操作系统/All_pic/Screenshot 2024-10-08 at 17.57.32.png" width=50%></img></center>
#### 7. 银行家算法举例
1. Pass